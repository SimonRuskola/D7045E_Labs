
<!DOCTYPE html>

<!--
   This page shows an animation of colored disks moving around
   in a canvas, bouncing off the edges.  The program uses WebGL.
   All of the points are drawn as single primitive of type POINTS.
   The color is an attribute in the vertex shader, allowing
   each point to be a different primitive.  The user can decide
   whether to have randomly colored points or to make all the
   points red.  The point size is a uniform variable, so all
   the points are the same size.  However, the user can select
   whether the size is large or small.
-->

<html>
<head>
<meta charset="UTF-8">
<title>Triangulation in WebGL</title>
<style>
    label {
        margin-left: 30px;
    }
</style>

<script>

"use strict";

const  vertexShaderSource =
       "attribute vec2 a_coords;\n" +
       "attribute vec3 a_color;\n" +
       "varying vec3 v_color;\n" +
       "uniform float u_width;\n" +
       "uniform float u_height;\n" +
       "uniform float u_pointSize;\n" + 
       "void main() {\n" +
       "   float x = -1.0 + 2.0*(a_coords.x / u_width);\n" +
       "   float y = 1.0 - 2.0*(a_coords.y / u_height);\n" +
       "   gl_Position = vec4(x, y, 0.0, 1.0);\n" +
       "   v_color = a_color;\n" +
       "   gl_PointSize = u_pointSize;\n" + 
       "}\n";

const fragmentShaderSource =
       "precision mediump float;\n" +
       "varying vec3 v_color;\n" +
       "void main() {\n" +
       "   gl_FragColor = vec4(v_color, 1.0);\n" +
       "}\n";

let  canvas;  // The canvas where WebGL draws.
let  gl;  // The WebGL graphics context.

let  uniformWidth;   // Location of uniform named "u_width"
let  uniformHeight;  // Location of uniform named "u_height"

let  attributeCoords;  // Location of the attribute named "a_coords".
let  bufferCoords;     // A vertex buffer object to hold the values for coords.

let  attributeColor;   // Location of the attribute named "a_color".
let  bufferColor;     // A vertex buffer object to hold the values for color.

let  POINT_COUNT = 20; // The number of points.  This can be changed by the user.
let  pointCoords = new Float32Array( 2*POINT_COUNT );
let  pointColors = new Float32Array( 3*POINT_COUNT );
let  pointSizes = new Float32Array( POINT_COUNT );

let triangleColors = [];
let triangleCoords = []; // Array to hold triangle coordinates

let bufferTriangles; // Buffer for triangle coordinates
let uniformPointSize;

function createPointData() { // called during initialization to fill the arrays with data.
    for (let i = 0; i < POINT_COUNT; i++) {

        pointSizes[i] = 5; // size of point
        let margin = pointSizes[i];
        pointCoords[2 * i] = margin + (canvas.width - 2 * margin) * Math.random();  // x-coordinate of point
        pointCoords[2 * i + 1] = margin + (canvas.height - 2 * margin) * Math.random();  // y-coordinate of point
      
    }
    for (let i = 0; i < POINT_COUNT; i++) {

        pointColors[i*3] = 0;
        pointColors[i*3 + 1] = 0;
        pointColors[i*3 + 2] = 0;
    }
}

function draw() {

    gl.clearColor(128 / 255, 128 / 255, 128 / 255, 1.0);  // specify the color to be used for clearing
    gl.clear(gl.COLOR_BUFFER_BIT);  // clear the canvas 
    
    gl.uniform1f(uniformPointSize, 5.0);
    
    /* Set up values for the "coords" attribute, giving point's positions */

    gl.bindBuffer(gl.ARRAY_BUFFER, bufferCoords);
    gl.bufferData(gl.ARRAY_BUFFER, pointCoords, gl.STREAM_DRAW);
    gl.vertexAttribPointer(attributeCoords, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(attributeCoords); 

    gl.bindBuffer(gl.ARRAY_BUFFER, bufferColor);
    gl.bufferData(gl.ARRAY_BUFFER, pointColors, gl.STREAM_DRAW);
    gl.vertexAttribPointer(attributeColor, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(attributeColor);
    
    gl.drawArrays(gl.POINTS, 0, POINT_COUNT);

    if (triangleCoords.length > 0) {
        gl.bindBuffer(gl.ARRAY_BUFFER, bufferTriangles);
        gl.bufferData(gl.ARRAY_BUFFER, triangleCoords, gl.STREAM_DRAW);
        gl.vertexAttribPointer(attributeCoords, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(attributeCoords);

        gl.bindBuffer(gl.ARRAY_BUFFER, bufferColor);
        gl.bufferData(gl.ARRAY_BUFFER, triangleColors, gl.STREAM_DRAW);
        gl.vertexAttribPointer(attributeColor, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(attributeColor);

        gl.drawArrays(gl.TRIANGLES, 0, triangleCoords.length / 2);
    }
    
}

function createProgram(gl, vertexShaderSource, fragmentShaderSource) {
   let  vsh = gl.createShader( gl.VERTEX_SHADER );
   gl.shaderSource( vsh, vertexShaderSource );
   gl.compileShader( vsh );
   if ( ! gl.getShaderParameter(vsh, gl.COMPILE_STATUS) ) {
      throw new Error("Error in vertex shader:  " + gl.getShaderInfoLog(vsh));
   }
   let  fsh = gl.createShader( gl.FRAGMENT_SHADER );
   gl.shaderSource( fsh, fragmentShaderSource );
   gl.compileShader( fsh );
   if ( ! gl.getShaderParameter(fsh, gl.COMPILE_STATUS) ) {
      throw new Error("Error in fragment shader:  " + gl.getShaderInfoLog(fsh));
   }
   let  prog = gl.createProgram();
   gl.attachShader( prog, vsh );
   gl.attachShader( prog, fsh );
   gl.linkProgram( prog );
   if ( ! gl.getProgramParameter( prog, gl.LINK_STATUS) ) {
      throw new Error("Link error in program:  " + gl.getProgramInfoLog(prog));
   }
   return prog;
}

/**
 * Initialize the WebGL graphics context
 */
function initGL() {
    let  prog = createProgram( gl, vertexShaderSource, fragmentShaderSource );
    gl.useProgram(prog);

    attributeCoords = gl.getAttribLocation(prog, "a_coords");
    bufferCoords = gl.createBuffer();

    attributeColor = gl.getAttribLocation(prog, "a_color");
    bufferColor = gl.createBuffer();

    uniformHeight = gl.getUniformLocation(prog, "u_height");
    uniformWidth = gl.getUniformLocation(prog, "u_width");
    uniformPointSize = gl.getUniformLocation(prog, "u_pointSize"); 
    gl.uniform1f(uniformHeight, canvas.height);
    gl.uniform1f(uniformWidth, canvas.width);
    gl.uniform1f(uniformPointSize, 10.0);
   
    createPointData();

    // Create a buffer for triangle coordinates
    bufferTriangles = gl.createBuffer();
    
}

/**
 * Initialize the program.  This function is called after the page has been loaded.
 */
function init() {
    try {
        canvas = document.getElementById("webglcanvas");
        let  options = {  // no need for alpha channel or depth buffer in this program
            alpha: false,
            depth: false
        };
        gl = canvas.getContext("webgl", options);
              // (Note: this page would work with "webgl2", with no further modification.)
        if ( ! gl ) {
            throw "Browser does not support WebGL";
        }
    }
    catch (e) {
        document.getElementById("canvas-holder").innerHTML =
            "<p>Sorry, could not get a WebGL graphics context.</p>";
        return;
    }
    try {
        initGL();  // initialize the WebGL graphics context
    }
    catch (e) {
        document.getElementById("canvas-holder").innerHTML =
            "<p>Sorry, could not initialize the WebGL graphics context: " + e + "</p>";
        return;
    }
 
    draw();
}

function changePoints() {
    POINT_COUNT = Number(document.getElementById("pointsInput").value);
    pointCoords = new Float32Array( 2*POINT_COUNT );
    pointColors = new Float32Array( 3*POINT_COUNT );
    triangleCoords = [];
    triangleColors = [];
    init();
}

function triangulate() {

    console.log("Triangulating...");


     // Sort points by x-coordinate (and by y-coordinate if x-coordinates are the same)
    let points = [];
    for (let i = 0; i < POINT_COUNT; i++) {
        points.push({ x: pointCoords[2 * i], y: pointCoords[2 * i + 1] });
    }
    points.sort((a, b) => a.x === b.x ? a.y - b.y : a.x - b.x);

    // Initialize the first triangle with the first three points
    addTriangle(points[0].x, points[0].y, points[1].x, points[1].y, points[2].x, points[2].y);
    let convexHull = [];
    convexHull.push(points[0]);
    convexHull.push(points[1]);
    convexHull.push(points[2]);



    for (let i = 3; i< points.length; i++) {
        let newPoint = points[i];
        let lastPoint = convexHull[convexHull.length - 1];

        for (let j = 1; j < convexHull.length; j++) {

            let nextPoint = convexHull[(convexHull.length - 1 + j) % convexHull.length];

            let collision = checkCollision(convexHull, newPoint, nextPoint);
            console.log("collision: ");
            console.log(collision);

            if (!collision) {
                addTriangle(nextPoint.x, nextPoint.y, lastPoint.x, lastPoint.y, newPoint.x, newPoint.y); 
                
            }else {
                break;
            }
        }
        

    }


  
  
    triangleCoords = new Float32Array(triangleCoords);
    triangleColors = new Float32Array(triangleColors);

    gl.bindBuffer(gl.ARRAY_BUFFER, bufferTriangles);
    gl.bufferData(gl.ARRAY_BUFFER, triangleCoords, gl.STREAM_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, bufferColor);
    gl.bufferData(gl.ARRAY_BUFFER, triangleColors, gl.STREAM_DRAW);

    draw();
}

function checkCollision(convexHull, p1, p2){
    //check if the line between p1 and p2 intersects with any edge of the convex hull
    for (let i = 0; i < convexHull.length; i++) {
        let p3 = convexHull[i];
        let p4 = convexHull[(i + 1) % convexHull.length];
        if (doIntersect(p1, p2, p3, p4)) {
            return false;
        }
    }

}

function doIntersect(p1, p2, p3, p4){
    // Find the 4 orientations required for the general and special cases
    let o1 = orientation(p1, p2, p3);
    let o2 = orientation(p1, p2, p4);
    let o3 = orientation(p3, p4, p1);
    let o4 = orientation(p3, p4, p2);

    // General case
    if (o1 != o2 && o3 != o4) {
        return true;
    }

    // Special Cases
    // p1, p2 and p3 are colinear and p3 lies on segment p1p2
    if (o1 == 0 && onSegment(p1, p3, p2)) {
        return true;
    }

    // p1, p2 and p4 are colinear and p4 lies on segment p1p2
    if (o2 == 0 && onSegment(p1, p4, p2)) {
        return true;
    }

    // p3, p4 and p1 are colinear and p1 lies on segment p3p4
    if (o3 == 0 && onSegment(p3, p1, p4)) {
        return true;
    }

    // p3, p4 and p2 are colinear and p2 lies on segment p3p4
    if (o4 == 0 && onSegment(p3, p2, p4)) {
        return true;
    }

    return false; // Doesn't fall in any of the above cases

}

function orientation(p, q, r){
    // See https://www.geeksforgeeks.org/orientation-3-ordered-points/
    // for details of below formula.
    let val = (q.y - p.y) * (r.x - q.x) -(q.x - p.x) * (r.y - q.y);

    if (val == 0) {
        return 0; // colinear
    }
    return (val > 0) ? 1 : 2; // clock or counterclock wise
}   

    

function addTriangle(x1, y1, x2, y2, x3, y3) {
    // Add color data for each vertex of the triangle
    triangleColors.push(1.0, 0.0, 0.0); // Red color for the first vertex
    triangleColors.push(0.0, 1.0, 0.0); // Green color for the second vertex
    triangleColors.push(0.0, 0.0, 1.0); // Blue color for the third vertex
    // Add coordinates for each vertex of the triangle
    triangleCoords.push(x1, y1);
    triangleCoords.push(x2, y2);
    triangleCoords.push(x3, y3);
   
}


window.onload = init;  // Arrange for init() to be called after page has loaded.

</script>
</head>
<body>

<h2>Triangulation</h2>

<noscript><p><b>Sorry, but this page requires JavaScript.</b></p></noscript>

<p>
    <label><b>Number of Points:</b>&nbsp;<input type="number" id="pointsInput" value="20"></label>
    <button onclick="changePoints()">Change Points</button>
    <button onclick="triangulate()">Triangulate</button>
</p>


<div id="canvas-holder">
<canvas id="webglcanvas" width="800" height="600" ></canvas>
</div>

</body>
</html>