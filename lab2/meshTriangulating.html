<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Point Set Triangulation</title>
<script>
"use strict";

const vertexShaderSource =
    "attribute vec2 a_coords;\n" +
    "attribute vec3 a_color;\n" +
    "varying vec3 v_color;\n" +
    "void main() {\n" +
    "   gl_Position = vec4(a_coords, 0.0, 1.0);\n" +
    "   v_color = a_color;\n" +
    "}\n";

const fragmentShaderSource =
    "precision mediump float;\n" +
    "varying vec3 v_color;\n" +
    "void main() {\n" +
    "   gl_FragColor = vec4(v_color, 1.0);\n" +
    "}\n";

let gl;
let program;
let attributeCoords;
let bufferCoords;
let attributeColor;
let bufferColor;
let points = [];
let triangles = [];


function draw() {
    gl.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);

    if (points.length > 0) {
        gl.bindBuffer(gl.ARRAY_BUFFER, bufferCoords);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(points.flat()), gl.STREAM_DRAW);
        gl.vertexAttribPointer(attributeCoords, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(attributeCoords);

        let colors = new Float32Array(points.length * 3);
        for (let i = 0; i < points.length; i++) {
            colors.set([Math.random(), Math.random(), Math.random()], i * 3);
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, bufferColor);
        gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STREAM_DRAW);
        gl.vertexAttribPointer(attributeColor, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(attributeColor);

        gl.drawArrays(gl.POINTS, 0, points.length);
    }

    if (triangles.length > 0) {
        let indices = [];
        for (let triangle of triangles) {
            indices.push(points.indexOf(triangle.vertices[0]));
            indices.push(points.indexOf(triangle.vertices[1]));
            indices.push(points.indexOf(triangle.vertices[2]));
        }

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STREAM_DRAW);

        gl.uniform4f(gl.getUniformLocation(program, "u_color"), 0, 0, 0, 1);
        gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);

        gl.uniform4f(gl.getUniformLocation(program, "u_color"), 1, 1, 1, 1);
        for (let i = 0; i < indices.length; i += 3) {
            gl.drawElements(gl.LINE_LOOP, 3, gl.UNSIGNED_SHORT, i * 2);
        }
    }
}

function createProgram(gl, vertexShaderSource, fragmentShaderSource) {
    let vsh = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vsh, vertexShaderSource);
    gl.compileShader(vsh);
    if (!gl.getShaderParameter(vsh, gl.COMPILE_STATUS)) {
        throw new Error("Error in vertex shader: " + gl.getShaderInfoLog(vsh));
    }
    let fsh = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fsh, fragmentShaderSource);
    gl.compileShader(fsh);
    if (!gl.getShaderParameter(fsh, gl.COMPILE_STATUS)) {
        throw new Error("Error in fragment shader: " + gl.getShaderInfoLog(fsh));
    }
    let prog = gl.createProgram();
    gl.attachShader(prog, vsh);
    gl.attachShader(prog, fsh);
    gl.linkProgram(prog);
    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        throw new Error("Link error in program: " + gl.getProgramInfoLog(prog));
    }
    return prog;
}

function initGL() {
    let prog = createProgram(gl, vertexShaderSource, fragmentShaderSource);
    gl.useProgram(prog);
    attributeCoords = gl.getAttribLocation(prog, "a_coords");
    bufferCoords = gl.createBuffer();
    attributeColor = gl.getAttribLocation(prog, "a_color");
    bufferColor = gl.createBuffer();
}

function init() {
    try {
        let canvas = document.getElementById("webglcanvas");
        let options = { alpha: false, depth: false };
        gl = canvas.getContext("webgl", options);
        if (!gl) {
            throw "Browser does not support WebGL";
        }
    } catch (e) {
        document.getElementById("canvas-holder").innerHTML =
            "<p>Sorry, could not get a WebGL graphics context.</p>";
        return;
    }
    try {
        initGL();
    } catch (e) {
        document.getElementById("canvas-holder").innerHTML =
            "<p>Sorry, could not initialize the WebGL graphics context: " + e.message + "</p>";
        return;
    }
    draw();
}

class Triangle {
    constructor(v0, v1, v2) {
        this.vertices = [v0, v1, v2];
        this.neighbors = [null, null, null];
    }

    setNeighbor(edgeIndex, neighbor) {
        this.neighbors[edgeIndex] = neighbor;
    }
}

function generateRandomPoints(count) {
    points = [];
    for (let i = 0; i < count; i++) {
        points.push([Math.random() * 2 - 1, Math.random() * 2 - 1]);
    }
    draw();
}

function triangulate() {
    points.sort((a, b) => a[0] - b[0]);
    triangles = incrementalTriangulation(points);
    draw();
}

function incrementalTriangulation(points) {
     // Placeholder for the incremental triangulation algorithm
    // Return an array of Triangle objects
    let triangles = [];
    // Example: Create a single triangle for demonstration
    if (points.length >= 3) {
        let tri = new Triangle(points[0], points[1], points[2]);
        triangles.push(tri);
    }
    return triangles;
}

window.onload = init;
</script>
</head>
<body>
<h2>Triangulate in WebGL</h2>
<noscript><p><b>Sorry, but this page requires JavaScript.</b></p></noscript>
<div id="controls">
    <button onclick="generateRandomPoints(10)">Generate 10 Points</button>
    <button onclick="generateRandomPoints(100)">Generate 100 Points</button>
    <button onclick="generateRandomPoints(1000)">Generate 1000 Points</button>
    <button onclick="triangulate()">Triangulate</button>
</div>
<div id="canvas-holder">
    <canvas id="webglcanvas" width="600" height="600"></canvas>
</div>
</body>
</html>